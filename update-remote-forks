#!/bin/bash
#
# Script used to handle the updating of remote repos
# that I have forked. All branches and tags are updated
# on the remote repo from the upstream (or original repo).

getopts "v" opt

case "$opt" in
    # -v is for verbose (applies mostly to git here), but in 
    # this case it also prints commands and their arguments as they execute
    "v")    set -ex
            GIT_CLONE=( git clone --verbose )
            GIT_BRANCH=( git branch --verbose )
            GIT_PUSH=( git push --verbose --force )
            ;;
    *)      set -e
            GIT_CLONE=( git clone --quiet )
            GIT_BRANCH=( git branch --quiet )
            GIT_PUSH=( git push --quiet --force )
            ;;
esac

# NOTE: is it assumed that the system running the script
# is configured to be able to push to the remote forked repo(s)
PROGRAM_NAME="$(basename "$0")"
PYTHON_EXECUTABLE="$(which python3)"
TEMP_DIR_NAME="$PROGRAM_NAME-temp"
DISABLE_GITHUB_ACTIONS_SCRIPTNAME="disable-github-actions.py"
FORKED_GIT_REMOTE_NAME="custom-fork"
WEBHOSTED_GIT_ACCOUNT_URL=""
declare -A FORKED_REPO_NAMES_TO_UPSTREAM_URLS=(
    # ["forked_repo_name"]=>"upstream_url"
)

if [ -z "$(which git)" ]; then
    echo "${PROGRAM_NAME}: git cannot be found on the PATH!"
    exit 1
fi

if [ -z "$(which $DISABLE_GITHUB_ACTIONS_SCRIPTNAME)" ]; then
    echo "${PROGRAM_NAME}: $DISABLE_GITHUB_ACTIONS_SCRIPTNAME cannot be found on the PATH!"
    exit 1
fi

if [ -z "$PYTHON_EXECUTABLE" ] || [ "$($PYTHON_EXECUTABLE --version | grep --regexp "Python 3\..*" --count)" -eq 0 ]; then
    echo "${PROGRAM_NAME}: 'python3' does not point to a python 3 interpreter"
    exit 1
fi

if [ -d "$TEMP_DIR_NAME" ]; then
    rm --recursive --force "$TEMP_DIR_NAME"
fi

mkdir "$TEMP_DIR_NAME" || exit 1
cd "$TEMP_DIR_NAME" || exit 1

for forked_repo_name in "${!FORKED_REPO_NAMES_TO_UPSTREAM_URLS[@]}"; do
    upstream="${FORKED_REPO_NAMES_TO_UPSTREAM_URLS["$forked_repo_name"]}"
    # NOTE: "$upstream" should follow parameter expansion, then being 
    # seen to python as os.path.basename("{results from parameter expansion}")
    upstream_repo_name="$($PYTHON_EXECUTABLE -c 'import os; print(os.path.basename('\""$upstream"\"'))')"
    "${GIT_CLONE[@]}" "$upstream" "$upstream_repo_name" > /dev/null
    cd "$upstream_repo_name"
    # seqeuence of commands inspired from:
    # https://stackoverflow.com/questions/15779740/how-to-update-my-fork-to-have-the-same-branches-and-tags-as-the-original-reposit
    # https://stackoverflow.com/questions/379081/track-all-remote-git-branches-as-local-branches/6300386#answer-27234826
    git remote add "$FORKED_GIT_REMOTE_NAME" "$($PYTHON_EXECUTABLE -c 'import os; print(os.path.join('\""$WEBHOSTED_GIT_ACCOUNT_URL"\"', '\""$forked_repo_name"\"'))')"
    for short_refname in $(git branch --remotes | grep --invert-match --extended-regexp "HEAD|master"); do 
        "${GIT_BRANCH[@]}" --track "${short_refname#*/}" "$short_refname"; 
    done
    "${GIT_PUSH[@]}" --all "$FORKED_GIT_REMOTE_NAME"
    "${GIT_PUSH[@]}" --tags "$FORKED_GIT_REMOTE_NAME"
    "$PYTHON_EXECUTABLE" "$(which "${DISABLE_GITHUB_ACTIONS_SCRIPTNAME}")" "$forked_repo_name"
    cd ..
done

cd ..
rm --recursive --force "$TEMP_DIR_NAME"

exit 0
