#!/bin/sh
#
# My attempt in creating something similar to Python's
# os.path.join (and any other language's variation of this).

#######################################
# Used to join together 'file' entries into
# a path on the file system.
# Arguments:
#   $n: file(s) to concatenate into a filesystem
#   path
# Outputs:
#   - Conjoined file entries to stdout
#######################################
pathjoin () {
    PROGRAM_NAME="pathjoin"
    path_prefix="/"
    help_option=false
    HELP_LONG_OPTION="help"
    RELATIVE_PATH_LONG_OPTION="relative-path"
    eval set -- "$(getopt --options hr --long "$HELP_LONG_OPTION","$RELATIVE_PATH_LONG_OPTION" --name "$PROGRAM_NAME" -- "$@")"
    # for the sakes of readability, do not shove short options into variables!
    while true; do
        case "$1" in
            "-h" | "--${HELP_LONG_OPTION}")             help_option=true; shift ;;
            "-r" | "--${RELATIVE_PATH_LONG_OPTION}")    path_prefix="./"; shift ;;
            "--")                                       shift; break ;;
            *)                                          break ;;
        esac
    done

    if [ "$#" -eq 0 ] || $help_option; then
        cat << _EOF_
Usage: $PROGRAM_NAME [-h] [-r] [PATH...]

Takes one or more filesystem paths and conjoins them. Duplicate
forward slashes (e.g. $PROGRAM_NAME foo/ /bar, /foo/bar would be 
the result) are accounted for. By default, an absolute path is 
assumed, but this can be overwritten.

Options:
    -h, --help              show this help message and exit
    -r, --relative-path     a relative path is constructed over an absolute path

_EOF_
        return 1
    fi

    completed_path="$path_prefix"
    while [ "$#" -gt 0 ]; do
        arg="$1"
        # NOTE: -2 to deal with newline from echo, sh doesn't understand flags
        # to echo...apparently and to deal with getting right end index
        completed_path_end=$(($(echo "$completed_path" | wc --chars)-2))
        if [ "${#completed_path}" -eq 1 ] && [ "$arg" = '/' ]; then
            # don't do anything, ignore the '/' inserted as an argument
            arg=
        elif [ "${#completed_path}" -eq 1 ] && [ "$(expr "$arg" : ".\{0,0\}\(.\{0,1\}\)")" != '/' ]; then
            # NOTES: looking to see if directory separator is added in front of arg AND
            # if this will be the first path to be added to the completed_path.
            # Don't do anything, as this is the first part of the completed path.
            :
        # sh version of ${string:position:length}, inspired by:
        # https://mywiki.wooledge.org/Bashism
        # $(expr "x$name" : "x.\{0,$n\}\(.\{0,$l\}\)")
        elif [ "$(expr "$completed_path" : ".\{0,$completed_path_end\}\(.\{0,1\}\)")" != '/' ] && [ "$(expr "$arg" : ".\{0,0\}\(.\{0,1\}\)")" != '/' ]; then
            # NOTE: looking to see if directory separator is added in front of arg OR
            # is the last char from the completed_path
            arg="/${arg}"
        elif [ "$(expr "$completed_path" : ".\{0,$completed_path_end\}\(.\{0,1\}\)")" = '/' ] && [ "$(expr "$arg" : ".\{0,0\}\(.\{0,1\}\)")" = '/' ]; then
            # NOTE: looking to see if directory separator is added in front of arg AND
            # is the last char from the completed_path.
            arg="$(expr "$arg" : ".\{0,1\}\(.\{0,$(($(echo "$arg" | wc --chars)-2))\}\)")"
        fi
        completed_path="${completed_path}${arg}"
        shift
    done

    echo "$completed_path"
    return 0
}

# NOTES: are we executing the script (rather than sourcing it)?
# Inspired by: https://superuser.com/questions/731425/bash-detect-execute-vs-source-in-a-script
# shellcheck disable=2116
if [ "$(basename "$0")" = "pathjoin" ]; then
    pathjoin "$@"
    exit
fi
